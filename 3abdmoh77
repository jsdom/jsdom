//<![CDATA[ $(".scroll-down").click(function() { var offset = 20; //Offset of 20px $('html, body').animate({ scrollTop: $("#purpose-wrapper").offset().top + offset }, 2000); }); // SmoothScroll v1.2.1 // Licensed under the terms of the MIT license. // People involved // - Balazs Galambosi (maintainer) // - Patrick Brunner (original idea) // - Michael Herf (Pulse Algorithm) // - Justin Force (Resurect) // Scroll Variables (tweakable) var framerate = 150; // [Hz] var animtime = 800; // [px] var stepsize = 80; // [px] // Pulse (less tweakable) // ratio of "tail" to "acceleration" var pulseAlgorithm = true; var pulseScale = 8; var pulseNormalize = 1; // Acceleration var acceleration = true; var accelDelta = 10; // 20 var accelMax = 1; // 1 // Keyboard Settings var keyboardsupport = true; // option var disableKeyboard = false; // other reasons var arrowscroll = 50; // [px] // Excluded pages var exclude = ""; var disabled = false; // Other Variables var frame = false; var direction = { x: 0, y: 0 }; var initdone = false; var fixedback = true; var root = document.documentElement; var activeElement; var key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36 }; /** * Sets up scrolls array, determines if frames are involved. */ function init() { if (!document.body) return; var body = document.body; var html = document.documentElement; var windowHeight = window.innerHeight; var scrollHeight = body.scrollHeight; // check compat mode for root element root = (document.compatMode.indexOf('CSS') >= 0) ? html : body; activeElement = body; initdone = true; // Checks if this script is running in a frame if (top != self) { frame = true; } /** * This fixes a bug where the areas left and right to * the content does not trigger the onmousewheel event * on some pages. e.g.: html, body { height: 100% } */ else if (scrollHeight > windowHeight && (body.offsetHeight <= windowHeight || html.offsetHeight <= windowHeight)) { // DOMChange (throttle): fix height var pending = false; var refresh = function() { if (!pending && html.scrollHeight != document.height) { pending = true; // add a new pending action setTimeout(function(){ html.style.height = document.height + 'px'; pending = false; }, 500); // act rarely to stay fast } }; html.style.height = ''; setTimeout(refresh, 10); addEvent("DOMNodeInserted", refresh); addEvent("DOMNodeRemoved", refresh); // clearfix if (root.offsetHeight <= windowHeight) { var underlay = document.createElement("div"); underlay.style.clear = "both"; body.appendChild(underlay); } } // gmail performance fix if (document.URL.indexOf("mail.google.com") > -1) { var s = document.createElement("style"); s.innerHTML = ".iu { visibility: hidden }"; (document.getElementsByTagName("head")[0] || html).appendChild(s); } // disable fixed background if (!fixedback && !disabled) { body.style.backgroundAttachment = "scroll"; html.style.backgroundAttachment = "scroll"; } } /************************************************ * SCROLLING ************************************************/ var que = []; var pending = false; var lastScroll = +new Date; /** * Pushes scroll actions to the scrolling queue. */ function scrollArray(elem, left, top, delay) { delay || (delay = 1000); directionCheck(left, top); if (acceleration) { var now = +new Date; var elapsed = now - lastScroll; if (elapsed < accelDelta) { var factor = (1 + (30 / elapsed)) / 2; if (factor > 1) { factor = Math.min(factor, accelMax); left *= factor; top *= factor; } } lastScroll = +new Date; } // push a scroll command que.push({ x: left, y: top, lastX: (left < 0) ? 0.99 : -0.99, lastY: (top < 0) ? 0.99 : -0.99, start: +new Date }); // don't act if there's a pending queue if (pending) { return; } var scrollWindow = (elem === document.body); var step = function() { var now = +new Date; var scrollX = 0; var scrollY = 0; for (var i = 0; i < que.length; i++) { var item = que[i]; var elapsed = now - item.start; var finished = (elapsed >= animtime); // scroll position: [0, 1] var position = (finished) ? 1 : elapsed / animtime; // easing [optional] if (pulseAlgorithm) { position = pulse(position); } // only need the difference var x = (item.x * position - item.lastX) >> 0; var y = (item.y * position - item.lastY) >> 0; // add this to the total scrolling scrollX += x; scrollY += y; // update last values item.lastX += x; item.lastY += y; // delete and step back if it's over if (finished) { que.splice(i, 1); i--; } } // scroll left and top if (scrollWindow) { window.scrollBy(scrollX, scrollY) } else { if (scrollX) elem.scrollLeft += scrollX; if (scrollY) elem.scrollTop += scrollY; } // clean up if there's nothing left to do if (!left && !top) { que = []; } if (que.length) { requestFrame(step, elem, (delay / framerate + 1)); } else { pending = false; } } // start a new queue of actions requestFrame(step, elem, 0); pending = true; } /*********************************************** * EVENTS ***********************************************/ /** * Mouse wheel handler. * @param {Object} event */ function wheel(event) { if (!initdone) { init(); } var target = event.target; var overflowing = overflowingAncestor(target); // use default if there's no overflowing // element or default action is prevented if (!overflowing || event.defaultPrevented || isNodeName(activeElement, "embed") || (isNodeName(target, "embed") && /\.pdf/i.test(target.src))) { return true; } var deltaX = event.wheelDeltaX || 0; var deltaY = event.wheelDeltaY || 0; // use wheelDelta if deltaX/Y is not available if (!deltaX && !deltaY) { deltaY = event.wheelDelta || 0; } // scale by step size // delta is 120 most of the time // synaptics seems to send 1 sometimes if (Math.abs(deltaX) > 1.2) { deltaX *= stepsize / 120; } if (Math.abs(deltaY) > 1.2) { deltaY *= stepsize / 120; } scrollArray(overflowing, -deltaX, -deltaY); event.preventDefault(); } /** * Keydown event handler. * @param {Object} event */ function keydown(event) { var target = event.target; var modifier = event.ctrlKey || event.altKey || event.metaKey || (event.shiftKey && event.keyCode !== key.spacebar); // do nothing if user is editing text // or using a modifier key (except shift) // or in a dropdown if ( /input|textarea|select|embed/i.test(target.nodeName) || target.isContentEditable || event.defaultPrevented || modifier ) { return true; } // spacebar should trigger button press if (isNodeName(target, "button") && event.keyCode === key.spacebar) { return true; } var shift, x = 0, y = 0; var elem = overflowingAncestor(activeElement); var clientHeight = elem.clientHeight; if (elem == document.body) { clientHeight = window.innerHeight; } switch (event.keyCode) { case key.up: y = -arrowscroll; break; case key.down: y = arrowscroll; break; case key.spacebar: // (+ shift) shift = event.shiftKey ? 1 : -1; y = -shift * clientHeight * 0.9; break; case key.pageup: y = -clientHeight * 0.9; break; case key.pagedown: y = clientHeight * 0.9; break; case key.home: y = -elem.scrollTop; break; case key.end: var damt = elem.scrollHeight - elem.scrollTop - clientHeight; y = (damt > 0) ? damt+10 : 0; break; case key.left: x = -arrowscroll; break; case key.right: x = arrowscroll; break; default: return true; // a key we don't care about } scrollArray(elem, x, y); event.preventDefault(); } /** * Mousedown event only for updating activeElement */ function mousedown(event) { activeElement = event.target; } /*********************************************** * OVERFLOW ***********************************************/ var cache = {}; // cleared out every once in while setInterval(function(){ cache = {}; }, 10 * 1000); var uniqueID = (function() { var i = 0; return function (el) { return el.uniqueID || (el.uniqueID = i++); }; })(); function setCache(elems, overflowing) { for (var i = elems.length; i--;) cache[uniqueID(elems[i])] = overflowing; return overflowing; } function overflowingAncestor(el) { var elems = []; var rootScrollHeight = root.scrollHeight; do { var cached = cache[uniqueID(el)]; if (cached) { return setCache(elems, cached); } elems.push(el); if (rootScrollHeight === el.scrollHeight) { if (!frame || root.clientHeight + 10 < rootScrollHeight) { return setCache(elems, document.body); // scrolling root in WebKit } } else if (el.clientHeight + 10 < el.scrollHeight) { overflow = getComputedStyle(el, "").getPropertyValue("overflow-y"); if (overflow === "scroll" || overflow === "auto") { return setCache(elems, el); } } } while (el = el.parentNode); } /*********************************************** * HELPERS ***********************************************/ function addEvent(type, fn, bubble) { window.addEventListener(type, fn, (bubble||false)); } function removeEvent(type, fn, bubble) { window.removeEventListener(type, fn, (bubble||false)); } function isNodeName(el, tag) { return (el.nodeName||"").toLowerCase() === tag.toLowerCase(); } function directionCheck(x, y) { x = (x > 0) ? 1 : -1; y = (y > 0) ? 1 : -1; if (direction.x !== x || direction.y !== y) { direction.x = x; direction.y = y; que = []; lastScroll = 0; } } var requestFrame = (function(){ return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback, element, delay){ window.setTimeout(callback, delay || (1000/60)); }; })(); /*********************************************** * PULSE ***********************************************/ /** * Viscous fluid with a pulse for part and decay for the rest. * - Applies a fixed force over an interval (a damped acceleration), and * - Lets the exponential bleed away the velocity over a longer interval * - Michael Herf, http://stereopsis.com/stopping/ */ function pulse_(x) { var val, start, expx; // test x = x * pulseScale; if (x < 1) { // acceleartion val = x - (1 - Math.exp(-x)); } else { // tail // the previous animation ended here: start = Math.exp(-1); // simple viscous drag x -= 1; expx = 1 - Math.exp(-x); val = start + (expx * (1 - start)); } return val * pulseNormalize; } function pulse(x) { if (x >= 1) return 1; if (x <= 0) return 0; if (pulseNormalize == 1) { pulseNormalize /= pulse_(1); } return pulse_(x); } addEvent("mousedown", mousedown); addEvent("mousewheel", wheel); addEvent("load", init); /*! * Stellar.js v0.6.2 * http://markdalgleish.com/projects/stellar.js * * Copyright 2014, Mark Dalgleish * This content is released under the MIT license * http://markdalgleish.mit-license.org */ ;(function($, window, document, undefined) { var pluginName = 'stellar', defaults = { scrollProperty: 'scroll', positionProperty: 'position', horizontalScrolling: true, verticalScrolling: true, horizontalOffset: 0, verticalOffset: 0, responsive: false, parallaxBackgrounds: true, parallaxElements: true, hideDistantElements: true, hideElement: function($elem) { $elem.hide(); }, showElement: function($elem) { $elem.show(); } }, scrollProperty = { scroll: { getLeft: function($elem) { return $elem.scrollLeft(); }, setLeft: function($elem, val) { $elem.scrollLeft(val); }, getTop: function($elem) { return $elem.scrollTop(); }, setTop: function($elem, val) { $elem.scrollTop(val); } }, position: { getLeft: function($elem) { return parseInt($elem.css('left'), 10) * -1; }, getTop: function($elem) { return parseInt($elem.css('top'), 10) * -1; } }, margin: { getLeft: function($elem) { return parseInt($elem.css('margin-left'), 10) * -1; }, getTop: function($elem) { return parseInt($elem.css('margin-top'), 10) * -1; } }, transform: { getLeft: function($elem) { var computedTransform = getComputedStyle($elem[0])[prefixedTransform]; return (computedTransform !== 'none' ? parseInt(computedTransform.match(/(-?[0-9]+)/g)[4], 10) * -1 : 0); }, getTop: function($elem) { var computedTransform = getComputedStyle($elem[0])[prefixedTransform]; return (computedTransform !== 'none' ? parseInt(computedTransform.match(/(-?[0-9]+)/g)[5], 10) * -1 : 0); } } }, positionProperty = { position: { setLeft: function($elem, left) { $elem.css('left', left); }, setTop: function($elem, top) { $elem.css('top', top); } }, transform: { setPosition: function($elem, left, startingLeft, top, startingTop) { $elem[0].style[prefixedTransform] = 'translate3d(' + (left - startingLeft) + 'px, ' + (top - startingTop) + 'px, 0)'; } } }, // Returns a function which adds a vendor prefix to any CSS property name vendorPrefix = (function() { var prefixes = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/, style = $('script')[0].style, prefix = '', prop; for (prop in style) { if (prefixes.test(prop)) { prefix = prop.match(prefixes)[0]; break; } } if ('WebkitOpacity' in style) { prefix = 'Webkit'; } if ('KhtmlOpacity' in style) { prefix = 'Khtml'; } return function(property) { return prefix + (prefix.length > 0 ? property.charAt(0).toUpperCase() + property.slice(1) : property); }; }()), prefixedTransform = vendorPrefix('transform'), supportsBackgroundPositionXY = $('<div />', { style: 'background:#fff' }).css('background-position-x') !== undefined, setBackgroundPosition = (supportsBackgroundPositionXY ? function($elem, x, y) { $elem.css({ 'background-position-x': x, 'background-position-y': y }); } : function($elem, x, y) { $elem.css('background-position', x + ' ' + y); } ), getBackgroundPosition = (supportsBackgroundPositionXY ? function($elem) { return [ $elem.css('background-position-x'), $elem.css('background-position-y') ]; } : function($elem) { return $elem.css('background-position').split(' '); } ), requestAnimFrame = ( window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / 60); } ); function Plugin(element, options) { this.element = element; this.options = $.extend({}, defaults, options); this._defaults = defaults; this._name = pluginName; this.init(); } Plugin.prototype = { init: function() { this.options.name = pluginName + '_' + Math.floor(Math.random() * 1e9); this._defineElements(); this._defineGetters(); this._defineSetters(); this._handleWindowLoadAndResize(); this._detectViewport(); this.refresh({ firstLoad: true }); if (this.options.scrollProperty === 'scroll') { this._handleScrollEvent(); } else { this._startAnimationLoop(); } }, _defineElements: function() { if (this.element === document.body) this.element = window; this.$scrollElement = $(this.element); this.$element = (this.element === window ? $('body') : this.$scrollElement); this.$viewportElement = (this.options.viewportElement !== undefined ? $(this.options.viewportElement) : (this.$scrollElement[0] === window || this.options.scrollProperty === 'scroll' ? this.$scrollElement : this.$scrollElement.parent()) ); }, _defineGetters: function() { var self = this, scrollPropertyAdapter = scrollProperty[self.options.scrollProperty]; this._getScrollLeft = function() { return scrollPropertyAdapter.getLeft(self.$scrollElement); }; this._getScrollTop = function() { return scrollPropertyAdapter.getTop(self.$scrollElement); }; }, _defineSetters: function() { var self = this, scrollPropertyAdapter = scrollProperty[self.options.scrollProperty], positionPropertyAdapter = positionProperty[self.options.positionProperty], setScrollLeft = scrollPropertyAdapter.setLeft, setScrollTop = scrollPropertyAdapter.setTop; this._setScrollLeft = (typeof setScrollLeft === 'function' ? function(val) { setScrollLeft(self.$scrollElement, val); } : $.noop); this._setScrollTop = (typeof setScrollTop === 'function' ? function(val) { setScrollTop(self.$scrollElement, val); } : $.noop); this._setPosition = positionPropertyAdapter.setPosition || function($elem, left, startingLeft, top, startingTop) { if (self.options.horizontalScrolling) { positionPropertyAdapter.setLeft($elem, left, startingLeft); } if (self.options.verticalScrolling) { positionPropertyAdapter.setTop($elem, top, startingTop); } }; }, _handleWindowLoadAndResize: function() { var self = this, $window = $(window); if (self.options.responsive) { $window.bind('load.' + this.name, function() { self.refresh(); }); } $window.bind('resize.' + this.name, function() { self._detectViewport(); if (self.options.responsive) { self.refresh(); } }); }, refresh: function(options) { var self = this, oldLeft = self._getScrollLeft(), oldTop = self._getScrollTop(); if (!options || !options.firstLoad) { this._reset(); } this._setScrollLeft(0); this._setScrollTop(0); this._setOffsets(); this._findParticles(); this._findBackgrounds(); // Fix for WebKit background rendering bug if (options && options.firstLoad && /WebKit/.test(navigator.userAgent)) { $(window).load(function() { var oldLeft = self._getScrollLeft(), oldTop = self._getScrollTop(); self._setScrollLeft(oldLeft + 1); self._setScrollTop(oldTop + 1); self._setScrollLeft(oldLeft); self._setScrollTop(oldTop); }); } this._setScrollLeft(oldLeft); this._setScrollTop(oldTop); }, _detectViewport: function() { var viewportOffsets = this.$viewportElement.offset(), hasOffsets = viewportOffsets !== null && viewportOffsets !== undefined; this.viewportWidth = this.$viewportElement.width(); this.viewportHeight = this.$viewportElement.height(); this.viewportOffsetTop = (hasOffsets ? viewportOffsets.top : 0); this.viewportOffsetLeft = (hasOffsets ? viewportOffsets.left : 0); }, _findParticles: function() { var self = this, scrollLeft = this._getScrollLeft(), scrollTop = this._getScrollTop(); if (this.particles !== undefined) { for (var i = this.particles.length - 1; i >= 0; i--) { this.particles[i].$element.data('stellar-elementIsActive', undefined); } } this.particles = []; if (!this.options.parallaxElements) return; this.$element.find('[data-stellar-ratio]').each(function(i) { var $this = $(this), horizontalOffset, verticalOffset, positionLeft, positionTop, marginLeft, marginTop, $offsetParent, offsetLeft, offsetTop, parentOffsetLeft = 0, parentOffsetTop = 0, tempParentOffsetLeft = 0, tempParentOffsetTop = 0; // Ensure this element isn't already part of another scrolling element if (!$this.data('stellar-elementIsActive')) { $this.data('stellar-elementIsActive', this); } else if ($this.data('stellar-elementIsActive') !== this) { return; } self.options.showElement($this); // Save/restore the original top and left CSS values in case we refresh the particles or destroy the instance if (!$this.data('stellar-startingLeft')) { $this.data('stellar-startingLeft', $this.css('left')); $this.data('stellar-startingTop', $this.css('top')); } else { $this.css('left', $this.data('stellar-startingLeft')); $this.css('top', $this.data('stellar-startingTop')); } positionLeft = $this.position().left; positionTop = $this.position().top; // Catch-all for margin top/left properties (these evaluate to 'auto' in IE7 and IE8) marginLeft = ($this.css('margin-left') === 'auto') ? 0 : parseInt($this.css('margin-left'), 10); marginTop = ($this.css('margin-top') === 'auto') ? 0 : parseInt($this.css('margin-top'), 10); offsetLeft = $this.offset().left - marginLeft; offsetTop = $this.offset().top - marginTop; // Calculate the offset parent $this.parents().each(function() { var $this = $(this); if ($this.data('stellar-offset-parent') === true) { parentOffsetLeft = tempParentOffsetLeft; parentOffsetTop = tempParentOffsetTop; $offsetParent = $this; return false; } else { tempParentOffsetLeft += $this.position().left; tempParentOffsetTop += $this.position().top; } }); // Detect the offsets horizontalOffset = ($this.data('stellar-horizontal-offset') !== undefined ? $this.data('stellar-horizontal-offset') : ($offsetParent !== undefined && $offsetParent.data('stellar-horizontal-offset') !== undefined ? $offsetParent.data('stellar-horizontal-offset') : self.horizontalOffset)); verticalOffset = ($this.data('stellar-vertical-offset') !== undefined ? $this.data('stellar-vertical-offset') : ($offsetParent !== undefined && $offsetParent.data('stellar-vertical-offset') !== undefined ? $offsetParent.data('stellar-vertical-offset') : self.verticalOffset)); // Add our object to the particles collection self.particles.push({ $element: $this, $offsetParent: $offsetParent, isFixed: $this.css('position') === 'fixed', horizontalOffset: horizontalOffset, verticalOffset: verticalOffset, startingPositionLeft: positionLeft, startingPositionTop: positionTop, startingOffsetLeft: offsetLeft, startingOffsetTop: offsetTop, parentOffsetLeft: parentOffsetLeft, parentOffsetTop: parentOffsetTop, stellarRatio: ($this.data('stellar-ratio') !== undefined ? $this.data('stellar-ratio') : 1), width: $this.outerWidth(true), height: $this.outerHeight(true), isHidden: false }); }); }, _findBackgrounds: function() { var self = this, scrollLeft = this._getScrollLeft(), scrollTop = this._getScrollTop(), $backgroundElements; this.backgrounds = []; if (!this.options.parallaxBackgrounds) return; $backgroundElements = this.$element.find('[data-stellar-background-ratio]'); if (this.$element.data('stellar-background-ratio')) { $backgroundElements = $backgroundElements.add(this.$element); } $backgroundElements.each(function() { var $this = $(this), backgroundPosition = getBackgroundPosition($this), horizontalOffset, verticalOffset, positionLeft, positionTop, marginLeft, marginTop, offsetLeft, offsetTop, $offsetParent, parentOffsetLeft = 0, parentOffsetTop = 0, tempParentOffsetLeft = 0, tempParentOffsetTop = 0; // Ensure this element isn't already part of another scrolling element if (!$this.data('stellar-backgroundIsActive')) { $this.data('stellar-backgroundIsActive', this); } else if ($this.data('stellar-backgroundIsActive') !== this) { return; } // Save/restore the original top and left CSS values in case we destroy the instance if (!$this.data('stellar-backgroundStartingLeft')) { $this.data('stellar-backgroundStartingLeft', backgroundPosition[0]); $this.data('stellar-backgroundStartingTop', backgroundPosition[1]); } else { setBackgroundPosition($this, $this.data('stellar-backgroundStartingLeft'), $this.data('stellar-backgroundStartingTop')); } // Catch-all for margin top/left properties (these evaluate to 'auto' in IE7 and IE8) marginLeft = ($this.css('margin-left') === 'auto') ? 0 : parseInt($this.css('margin-left'), 10); marginTop = ($this.css('margin-top') === 'auto') ? 0 : parseInt($this.css('margin-top'), 10); offsetLeft = $this.offset().left - marginLeft - scrollLeft; offsetTop = $this.offset().top - marginTop - scrollTop; // Calculate the offset parent $this.parents().each(function() { var $this = $(this); if ($this.data('stellar-offset-parent') === true) { parentOffsetLeft = tempParentOffsetLeft; parentOffsetTop = tempParentOffsetTop; $offsetParent = $this; return false; } else { tempParentOffsetLeft += $this.position().left; tempParentOffsetTop += $this.position().top; } }); // Detect the offsets horizontalOffset = ($this.data('stellar-horizontal-offset') !== undefined ? $this.data('stellar-horizontal-offset') : ($offsetParent !== undefined && $offsetParent.data('stellar-horizontal-offset') !== undefined ? $offsetParent.data('stellar-horizontal-offset') : self.horizontalOffset)); verticalOffset = ($this.data('stellar-vertical-offset') !== undefined ? $this.data('stellar-vertical-offset') : ($offsetParent !== undefined && $offsetParent.data('stellar-vertical-offset') !== undefined ? $offsetParent.data('stellar-vertical-offset') : self.verticalOffset)); self.backgrounds.push({ $element: $this, $offsetParent: $offsetParent, isFixed: $this.css('background-attachment') === 'fixed', horizontalOffset: horizontalOffset, verticalOffset: verticalOffset, startingValueLeft: backgroundPosition[0], startingValueTop: backgroundPosition[1], startingBackgroundPositionLeft: (isNaN(parseInt(backgroundPosition[0], 10)) ? 0 : parseInt(backgroundPosition[0], 10)), startingBackgroundPositionTop: (isNaN(parseInt(backgroundPosition[1], 10)) ? 0 : parseInt(backgroundPosition[1], 10)), startingPositionLeft: $this.position().left, startingPositionTop: $this.position().top, startingOffsetLeft: offsetLeft, startingOffsetTop: offsetTop, parentOffsetLeft: parentOffsetLeft, parentOffsetTop: parentOffsetTop, stellarRatio: ($this.data('stellar-background-ratio') === undefined ? 1 : $this.data('stellar-background-ratio')) }); }); }, _reset: function() { var particle, startingPositionLeft, startingPositionTop, background, i; for (i = this.particles.length - 1; i >= 0; i--) { particle = this.particles[i]; startingPositionLeft = particle.$element.data('stellar-startingLeft'); startingPositionTop = particle.$element.data('stellar-startingTop'); this._setPosition(particle.$element, startingPositionLeft, startingPositionLeft, startingPositionTop, startingPositionTop); this.options.showElement(particle.$element); particle.$element.data('stellar-startingLeft', null).data('stellar-elementIsActive', null).data('stellar-backgroundIsActive', null); } for (i = this.backgrounds.length - 1; i >= 0; i--) { background = this.backgrounds[i]; background.$element.data('stellar-backgroundStartingLeft', null).data('stellar-backgroundStartingTop', null); setBackgroundPosition(background.$element, background.startingValueLeft, background.startingValueTop); } }, destroy: function() { this._reset(); this.$scrollElement.unbind('resize.' + this.name).unbind('scroll.' + this.name); this._animationLoop = $.noop; $(window).unbind('load.' + this.name).unbind('resize.' + this.name); }, _setOffsets: function() { var self = this, $window = $(window); $window.unbind('resize.horizontal-' + this.name).unbind('resize.vertical-' + this.name); if (typeof this.options.horizontalOffset === 'function') { this.horizontalOffset = this.options.horizontalOffset(); $window.bind('resize.horizontal-' + this.name, function() { self.horizontalOffset = self.options.horizontalOffset(); }); } else { this.horizontalOffset = this.options.horizontalOffset; } if (typeof this.options.verticalOffset === 'function') { this.verticalOffset = this.options.verticalOffset(); $window.bind('resize.vertical-' + this.name, function() { self.verticalOffset = self.options.verticalOffset(); }); } else { this.verticalOffset = this.options.verticalOffset; } }, _repositionElements: function() { var scrollLeft = this._getScrollLeft(), scrollTop = this._getScrollTop(), horizontalOffset, verticalOffset, particle, fixedRatioOffset, background, bgLeft, bgTop, isVisibleVertical = true, isVisibleHorizontal = true, newPositionLeft, newPositionTop, newOffsetLeft, newOffsetTop, i; // First check that the scroll position or container size has changed if (this.currentScrollLeft === scrollLeft && this.currentScrollTop === scrollTop && this.currentWidth === this.viewportWidth && this.currentHeight === this.viewportHeight) { return; } else { this.currentScrollLeft = scrollLeft; this.currentScrollTop = scrollTop; this.currentWidth = this.viewportWidth; this.currentHeight = this.viewportHeight; } // Reposition elements for (i = this.particles.length - 1; i >= 0; i--) { particle = this.particles[i]; fixedRatioOffset = (particle.isFixed ? 1 : 0); // Calculate position, then calculate what the particle's new offset will be (for visibility check) if (this.options.horizontalScrolling) { newPositionLeft = (scrollLeft + particle.horizontalOffset + this.viewportOffsetLeft + particle.startingPositionLeft - particle.startingOffsetLeft + particle.parentOffsetLeft) * -(particle.stellarRatio + fixedRatioOffset - 1) + particle.startingPositionLeft; newOffsetLeft = newPositionLeft - particle.startingPositionLeft + particle.startingOffsetLeft; } else { newPositionLeft = particle.startingPositionLeft; newOffsetLeft = particle.startingOffsetLeft; } if (this.options.verticalScrolling) { newPositionTop = (scrollTop + particle.verticalOffset + this.viewportOffsetTop + particle.startingPositionTop - particle.startingOffsetTop + particle.parentOffsetTop) * -(particle.stellarRatio + fixedRatioOffset - 1) + particle.startingPositionTop; newOffsetTop = newPositionTop - particle.startingPositionTop + particle.startingOffsetTop; } else { newPositionTop = particle.startingPositionTop; newOffsetTop = particle.startingOffsetTop; } // Check visibility if (this.options.hideDistantElements) { isVisibleHorizontal = !this.options.horizontalScrolling || newOffsetLeft + particle.width > (particle.isFixed ? 0 : scrollLeft) && newOffsetLeft < (particle.isFixed ? 0 : scrollLeft) + this.viewportWidth + this.viewportOffsetLeft; isVisibleVertical = !this.options.verticalScrolling || newOffsetTop + particle.height > (particle.isFixed ? 0 : scrollTop) && newOffsetTop < (particle.isFixed ? 0 : scrollTop) + this.viewportHeight + this.viewportOffsetTop; } if (isVisibleHorizontal && isVisibleVertical) { if (particle.isHidden) { this.options.showElement(particle.$element); particle.isHidden = false; } this._setPosition(particle.$element, newPositionLeft, particle.startingPositionLeft, newPositionTop, particle.startingPositionTop); } else { if (!particle.isHidden) { this.options.hideElement(particle.$element); particle.isHidden = true; } } } // Reposition backgrounds for (i = this.backgrounds.length - 1; i >= 0; i--) { background = this.backgrounds[i]; fixedRatioOffset = (background.isFixed ? 0 : 1); bgLeft = (this.options.horizontalScrolling ? (scrollLeft + background.horizontalOffset - this.viewportOffsetLeft - background.startingOffsetLeft + background.parentOffsetLeft - background.startingBackgroundPositionLeft) * (fixedRatioOffset - background.stellarRatio) + 'px' : background.startingValueLeft); bgTop = (this.options.verticalScrolling ? (scrollTop + background.verticalOffset - this.viewportOffsetTop - background.startingOffsetTop + background.parentOffsetTop - background.startingBackgroundPositionTop) * (fixedRatioOffset - background.stellarRatio) + 'px' : background.startingValueTop); setBackgroundPosition(background.$element, bgLeft, bgTop); } }, _handleScrollEvent: function() { var self = this, ticking = false; var update = function() { self._repositionElements(); ticking = false; }; var requestTick = function() { if (!ticking) { requestAnimFrame(update); ticking = true; } }; this.$scrollElement.bind('scroll.' + this.name, requestTick); requestTick(); }, _startAnimationLoop: function() { var self = this; this._animationLoop = function() { requestAnimFrame(self._animationLoop); self._repositionElements(); }; this._animationLoop(); } }; $.fn[pluginName] = function (options) { var args = arguments; if (options === undefined || typeof options === 'object') { return this.each(function () { if (!$.data(this, 'plugin_' + pluginName)) { $.data(this, 'plugin_' + pluginName, new Plugin(this, options)); } }); } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') { return this.each(function () { var instance = $.data(this, 'plugin_' + pluginName); if (instance instanceof Plugin && typeof instance[options] === 'function') { instance[options].apply(instance, Array.prototype.slice.call(args, 1)); } if (options === 'destroy') { $.data(this, 'plugin_' + pluginName, null); } }); } }; $[pluginName] = function(options) { var $window = $(window); return $window.stellar.apply($window, Array.prototype.slice.call(arguments, 0)); }; // Expose the scroll and position property function hashes so they can be extended $[pluginName].scrollProperty = scrollProperty; $[pluginName].positionProperty = positionProperty; // Expose the plugin class so it can be modified window.Stellar = Plugin; }(jQuery, this, document)); /*! WOW - v1.0.2 - 2014-10-28 * Copyright (c) 2014 Matthieu Aussaguel; Licensed MIT */(function(){var a,b,c,d,e,f=function(a,b){return function(){return a.apply(b,arguments)}},g=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};b=function(){function a(){}return a.prototype.extend=function(a,b){var c,d;for(c in b)d=b[c],null==a[c]&&(a[c]=d);return a},a.prototype.isMobile=function(a){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a)},a.prototype.addEvent=function(a,b,c){return null!=a.addEventListener?a.addEventListener(b,c,!1):null!=a.attachEvent?a.attachEvent("on"+b,c):a[b]=c},a.prototype.removeEvent=function(a,b,c){return null!=a.removeEventListener?a.removeEventListener(b,c,!1):null!=a.detachEvent?a.detachEvent("on"+b,c):delete a[b]},a.prototype.innerHeight=function(){return"innerHeight"in window?window.innerHeight:document.documentElement.clientHeight},a}(),c=this.WeakMap||this.MozWeakMap||(c=function(){function a(){this.keys=[],this.values=[]}return a.prototype.get=function(a){var b,c,d,e,f;for(f=this.keys,b=d=0,e=f.length;e>d;b=++d)if(c=f[b],c===a)return this.values[b]},a.prototype.set=function(a,b){var c,d,e,f,g;for(g=this.keys,c=e=0,f=g.length;f>e;c=++e)if(d=g[c],d===a)return void(this.values[c]=b);return this.keys.push(a),this.values.push(b)},a}()),a=this.MutationObserver||this.WebkitMutationObserver||this.MozMutationObserver||(a=function(){function a(){"undefined"!=typeof console&&null!==console&&console.warn("MutationObserver is not supported by your browser."),"undefined"!=typeof console&&null!==console&&console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")}return a.notSupported=!0,a.prototype.observe=function(){},a}()),d=this.getComputedStyle||function(a){return this.getPropertyValue=function(b){var c;return"float"===b&&(b="styleFloat"),e.test(b)&&b.replace(e,function(a,b){return b.toUpperCase()}),(null!=(c=a.currentStyle)?c[b]:void 0)||null},this},e=/(\-([a-z]){1})/g,this.WOW=function(){function e(a){null==a&&(a={}),this.scrollCallback=f(this.scrollCallback,this),this.scrollHandler=f(this.scrollHandler,this),this.start=f(this.start,this),this.scrolled=!0,this.config=this.util().extend(a,this.defaults),this.animationNameCache=new c}return e.prototype.defaults={boxClass:"wow",animateClass:"animated",offset:0,mobile:!0,live:!0},e.prototype.init=function(){var a;return this.element=window.document.documentElement,"interactive"===(a=document.readyState)||"complete"===a?this.start():this.util().addEvent(document,"DOMContentLoaded",this.start),this.finished=[]},e.prototype.start=function(){var b,c,d,e;if(this.stopped=!1,this.boxes=function(){var a,c,d,e;for(d=this.element.querySelectorAll("."+this.config.boxClass),e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.all=function(){var a,c,d,e;for(d=this.boxes,e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.boxes.length)if(this.disabled())this.resetStyle();else for(e=this.boxes,c=0,d=e.length;d>c;c++)b=e[c],this.applyStyle(b,!0);return this.disabled()||(this.util().addEvent(window,"scroll",this.scrollHandler),this.util().addEvent(window,"resize",this.scrollHandler),this.interval=setInterval(this.scrollCallback,50)),this.config.live?new a(function(a){return function(b){var c,d,e,f,g;for(g=[],e=0,f=b.length;f>e;e++)d=b[e],g.push(function(){var a,b,e,f;for(e=d.addedNodes||[],f=[],a=0,b=e.length;b>a;a++)c=e[a],f.push(this.doSync(c));return f}.call(a));return g}}(this)).observe(document.body,{childList:!0,subtree:!0}):void 0},e.prototype.stop=function(){return this.stopped=!0,this.util().removeEvent(window,"scroll",this.scrollHandler),this.util().removeEvent(window,"resize",this.scrollHandler),null!=this.interval?clearInterval(this.interval):void 0},e.prototype.sync=function(){return a.notSupported?this.doSync(this.element):void 0},e.prototype.doSync=function(a){var b,c,d,e,f;if(null==a&&(a=this.element),1===a.nodeType){for(a=a.parentNode||a,e=a.querySelectorAll("."+this.config.boxClass),f=[],c=0,d=e.length;d>c;c++)b=e[c],g.call(this.all,b)<0?(this.boxes.push(b),this.all.push(b),this.stopped||this.disabled()?this.resetStyle():this.applyStyle(b,!0),f.push(this.scrolled=!0)):f.push(void 0);return f}},e.prototype.show=function(a){return this.applyStyle(a),a.className=""+a.className+" "+this.config.animateClass},e.prototype.applyStyle=function(a,b){var c,d,e;return d=a.getAttribute("data-wow-duration"),c=a.getAttribute("data-wow-delay"),e=a.getAttribute("data-wow-iteration"),this.animate(function(f){return function(){return f.customStyle(a,b,d,c,e)}}(this))},e.prototype.animate=function(){return"requestAnimationFrame"in window?function(a){return window.requestAnimationFrame(a)}:function(a){return a()}}(),e.prototype.resetStyle=function(){var a,b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],e.push(a.style.visibility="visible");return e},e.prototype.customStyle=function(a,b,c,d,e){return b&&this.cacheAnimationName(a),a.style.visibility=b?"hidden":"visible",c&&this.vendorSet(a.style,{animationDuration:c}),d&&this.vendorSet(a.style,{animationDelay:d}),e&&this.vendorSet(a.style,{animationIterationCount:e}),this.vendorSet(a.style,{animationName:b?"none":this.cachedAnimationName(a)}),a},e.prototype.vendors=["moz","webkit"],e.prototype.vendorSet=function(a,b){var c,d,e,f;f=[];for(c in b)d=b[c],a[""+c]=d,f.push(function(){var b,f,g,h;for(g=this.vendors,h=[],b=0,f=g.length;f>b;b++)e=g[b],h.push(a[""+e+c.charAt(0).toUpperCase()+c.substr(1)]=d);return h}.call(this));return f},e.prototype.vendorCSS=function(a,b){var c,e,f,g,h,i;for(e=d(a),c=e.getPropertyCSSValue(b),i=this.vendors,g=0,h=i.length;h>g;g++)f=i[g],c=c||e.getPropertyCSSValue("-"+f+"-"+b);return c},e.prototype.animationName=function(a){var b;try{b=this.vendorCSS(a,"animation-name").cssText}catch(c){b=d(a).getPropertyValue("animation-name")}return"none"===b?"":b},e.prototype.cacheAnimationName=function(a){return this.animationNameCache.set(a,this.animationName(a))},e.prototype.cachedAnimationName=function(a){return this.animationNameCache.get(a)},e.prototype.scrollHandler=function(){return this.scrolled=!0},e.prototype.scrollCallback=function(){var a;return!this.scrolled||(this.scrolled=!1,this.boxes=function(){var b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],a&&(this.isVisible(a)?this.show(a):e.push(a));return e}.call(this),this.boxes.length||this.config.live)?void 0:this.stop()},e.prototype.offsetTop=function(a){for(var b;void 0===a.offsetTop;)a=a.parentNode;for(b=a.offsetTop;a=a.offsetParent;)b+=a.offsetTop;return b},e.prototype.isVisible=function(a){var b,c,d,e,f;return c=a.getAttribute("data-wow-offset")||this.config.offset,f=window.pageYOffset,e=f+Math.min(this.element.clientHeight,this.util().innerHeight())-c,d=this.offsetTop(a),b=d+a.clientHeight,e>=d&&b>=f},e.prototype.util=function(){return null!=this._util?this._util:this._util=new b},e.prototype.disabled=function(){return!this.config.mobile&&this.util().isMobile(navigator.userAgent)},e}()}).call(this); // Parallax Background Image Effect $.stellar({ horizontalScrolling: false, verticalOffset: 40, responsive:true }); // WOW Animations new WOW().init(); var cfJsHost = (("https:" == document.location.protocol) ? "https://" : "http://"); document.write(unescape("%3Cscript src='" + cfJsHost + "dflzqrzibliy5.cloudfront.net/includes/tinybox/tinybox.js?8998' type='text/javascript'%3E%3C/script%3E")); $(document)['ready'](function () { $('#qaisi1web-prot')['html']('<a href="http://www.3arabety.cf" rel="dofollow" target="_blank">تصميم : عربيتي</a>'); setInterval(function () { if (!$('#qaisi1web-prot:visible')['length']) { window['location']['href'] = 'http://www.3arabety.cf'; }; }, 3000); }); //]]>
